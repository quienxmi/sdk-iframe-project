{"version":3,"file":"qxm-iframe-project.umd.js","sources":["../src/constants/errors.ts","../src/constants/allowedDomains.ts","../src/utils/checkDomain.ts","../src/utils/decodeToken.ts","../src/index.ts"],"sourcesContent":["import { Errors } from '@interfaces';\n\nconst errors: Errors = {\n    SDK_CREATE: 'The SDK could not be found.',\n    IFRAME_NOT_FOUND: 'The iframe could not be found.',\n    DOM_NOT_IFRAME: 'You cannot build the iframe because the DOM is not an iframe.',\n    INVALID_TOKEN: 'The token is expired or has an error. It is necessary to generate the token again.',\n    INVALID_DOMAIN: 'The source domain is not supported.',\n    ERROR_LOADING_IFRAME: 'The iframe could not be loaded correctly.'\n}\n\nexport default errors;","export default [\n    'localhost',\n    '.sandboxqxm.com',\n    '.quienpormi.com',\n    '.quienxmi.com',\n    '.qxm.com.'\n];","import AllowedDomains from '../constants/allowedDomains';\n\nexport function checkDomain(url: string): boolean {\n    try {\n        const parsedUrl = new URL(url);\n        const hostname = parsedUrl.hostname;\n        return AllowedDomains.some(domain => {\n            if (domain === 'localhost') {\n                return hostname === 'localhost';\n            } else {\n                if (parsedUrl.protocol !== 'https:') {\n                    return false;\n                }\n                if (domain.endsWith('.')) {\n                    return hostname.slice(0, -2).endsWith(domain);\n                }\n                return hostname.endsWith(domain);\n            }\n        });\n    } catch (err) {\n        return false;\n    }\n}","import { TokenDecode } from '@interfaces';\n\nconst requiredKeys = [\n    'iss',\n    'iat',\n    'exp',\n    'data'\n];\n\nfunction checkKeysInObject(jsonPayload: TokenDecode): boolean {\n    const payloadKeys = Object.keys(jsonPayload);\n    return requiredKeys.every(key => payloadKeys.includes(key));\n}\n\nexport function decodeToken(token: string) {\n    try {\n        const base64Url = token.split('.')[1];\n        const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');\n        const jsonPayload: TokenDecode = JSON.parse(decodeURIComponent(atob(base64).split('').map(function (c) {\n            return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n        }).join('')));\n        const currentTime = Math.floor(Date.now() / 1000);\n        if (jsonPayload.exp > currentTime && checkKeysInObject(jsonPayload)) {\n            return jsonPayload;\n        }\n        return null;\n    } catch (err) {\n        return null;\n    }\n}","import { Config, SubscriptionTypes, Observer, TokenDecode, EventObserver } from '@interfaces';\nimport './interfaces/global.d';\nimport Errors from './constants/errors';\nimport { checkDomain } from './utils/checkDomain';\nimport { decodeToken } from './utils/decodeToken';\nimport { version } from '../package.json';\n\nconst observersStructure = {\n    all: [],\n    resize: [],\n    modals: [],\n    error: []\n};\n\nclass QxmIframeProject {\n    public _domIframe?: HTMLIFrameElement;\n    public _observers: Observer = observersStructure;\n    \n    private _checkExp?: number | NodeJS.Timeout;\n    private _logs = false;\n\n    constructor(domOrStringIframe: HTMLIFrameElement | string, config: Config | null) {\n        try {\n            const { scrolling, resize, logs } = config ?? {};\n\n            if (typeof domOrStringIframe === 'string') {\n                this._domIframe = document.querySelector(domOrStringIframe)!;\n            } else {\n                this._domIframe = domOrStringIframe;\n            }\n\n            if (logs === true) {\n                this._logs = true;\n            }\n\n            if (this._logs) {\n                console.info('[QxmIframe]: Version ' + version)\n            }\n\n            if (!this._domIframe) {\n                this.errorLog('IFRAME_NOT_FOUND');\n                return;\n            }\n\n            if (!(this._domIframe instanceof HTMLIFrameElement)) {\n                this.errorLog('DOM_NOT_IFRAME');\n                return;\n            }\n\n            this._domIframe.setAttribute('frameborder', '0');\n\n            if (!(scrolling || false)) {\n                this._domIframe.setAttribute('scrolling', 'no');\n            }\n\n            this.createListener();\n\n            if (resize ?? true) {\n                this.subscribe('resize', this.resize);\n            }\n        } catch (e: any) {\n            this.errorLog('SDK_CREATE', e);\n        }\n    }\n\n    subscribe(type: SubscriptionTypes = 'all', callback: Function) {\n        this._observers[type].push(callback);\n    }\n\n    error(callback: Function) {\n        this.subscribe('error', callback);\n    }\n\n    modals(callback: Function) {\n        this.subscribe('modals', callback);\n    }\n\n    async setToken(token: string): Promise<TokenDecode | null> {\n        const tokenDecode: TokenDecode | null = decodeToken(token);\n\n        if (!tokenDecode) {\n            this.errorLog('INVALID_TOKEN');\n            return null;\n        }\n\n        if (!checkDomain(tokenDecode.iss)) {\n            this.errorLog('INVALID_DOMAIN');\n            return null;\n        }\n\n        this._checkExp = setInterval(() => {\n            const now = Math.floor(Date.now() / 1000);\n            if (tokenDecode.exp < now) {\n                this.errorLog('EXPIRED_TOKEN');\n                clearInterval(this._checkExp);\n            }\n        }, 1000);\n\n        if (!await this.setSrcIframe(tokenDecode.iss, token)) {\n            return null;\n        }\n\n        return tokenDecode;\n    }\n\n    destroy() {\n        this._domIframe = undefined;\n        this._observers = observersStructure;\n    }\n\n    private setSrcIframe(domain: string, token: string): Promise<boolean> {\n        return new Promise((resolve) => {\n            const domIframe = this._domIframe!;\n\n            const onLoad = () => {\n                clearEvents();\n                resolve(true);\n            };\n\n            const onError = () => {\n                this.errorLog('ERROR_LOADING_IFRAME');\n                clearEvents();\n                resolve(false);\n            };\n\n            const clearEvents = () => {\n                domIframe.removeEventListener('load', onLoad);\n                domIframe.removeEventListener('error', onError);\n            }\n\n            try {\n                domIframe.src = domain + '/api/iframe/project/create?token=' + token;\n                domIframe.addEventListener('load', onLoad);\n                domIframe.addEventListener('error', onError);\n            } catch (err) {\n                onError();\n            }\n        });\n    }\n\n    private createListener() {\n        window.addEventListener('message', (event: MessageEvent) => {\n            const { origin, data } = event;\n            if (checkDomain(origin)) {\n                if (this._logs) {\n                    console.log('[QxmIframe]:', data);\n                }\n                let type = data.type ?? 'all';\n                if (!this._observers[type]) {\n                    type = 'all';\n                }\n                this._observers[type].forEach((observer: Function) => observer({\n                    _domIframe: this._domIframe,\n                    data\n                }));\n            }\n        });\n    }\n\n    private errorLog(code: string, error: any = null) {\n        const message = Errors[code] ?? code;\n        if (this._logs) {\n            console.error('[QxmIframe]:', message, error);\n        }\n        this._observers.error.forEach((observer: Function) => observer({\n            _domIframe: this._domIframe,\n            code,\n            message,\n            error\n        }));\n    }\n\n    private resize(event: EventObserver) {\n        const { _domIframe, data } = event;\n        const styles = window.getComputedStyle(_domIframe);\n        const iframePadding = parseInt(styles.paddingTop) + parseInt(styles.paddingBottom);\n        _domIframe.style.setProperty('height', `${data.height + iframePadding}px`, 'important');\n    }\n}\n\nexport default QxmIframeProject;\nwindow.QxmIframeProject = QxmIframeProject;"],"names":["errors","AllowedDomains","checkDomain","url","parsedUrl","hostname","domain","requiredKeys","checkKeysInObject","jsonPayload","payloadKeys","key","decodeToken","token","base64","c","currentTime","observersStructure","QxmIframeProject","domOrStringIframe","config","__publicField","scrolling","resize","logs","version","e","type","callback","tokenDecode","now","resolve","domIframe","onLoad","clearEvents","onError","event","origin","data","observer","code","error","message","Errors","_domIframe","styles","iframePadding"],"mappings":"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"}